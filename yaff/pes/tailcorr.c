// YAFF is yet another force-field code.
// Copyright (C) 2011 Toon Verstraelen <Toon.Verstraelen@UGent.be>,
// Louis Vanduyfhuys <Louis.Vanduyfhuys@UGent.be>, Center for Molecular Modeling
// (CMM), Ghent University, Ghent, Belgium; all rights reserved unless otherwise
// stated.
//
// This file is part of YAFF.
//
// YAFF is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or (at your option) any later version.
//
// YAFF is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <http://www.gnu.org/licenses/>
//
// --
#include <math.h>
#include <stdlib.h>
#include "pair_pot.h"

double pair_tailcorr_cut_lj(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V:=4*epsilon*((sigma/r)**12-(sigma/r)**6);
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
  double sigma, epsilon;
  sigma = 0.5*(
    (*(pair_data_lj_type*)pair_data).sigma[center_index]+
    (*(pair_data_lj_type*)pair_data).sigma[other_index]
  );
  epsilon = sqrt(
    (*(pair_data_lj_type*)pair_data).epsilon[center_index]*
    (*(pair_data_lj_type*)pair_data).epsilon[other_index]
  );
  double t1 = pow(sigma, 0.2e1);
  double t2 = t1 * t1;
  double t3 = t2 * t1;
  double t5 = pow(rcut, 0.2e1);
  double t6 = t5 * t5;
  double t10 = t6 * t6;
  double t16 = -0.4e1 / 0.9e1 * epsilon * t3 * (0.3e1 * t6 * t5 - t3) / t10 / rcut;
  return t16;
}

double pair_tailcorr_switch3_lj(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V:=4*epsilon*((sigma/r)**12-(sigma/r)**6);
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
  double sigma, epsilon;
  sigma = 0.5*(
    (*(pair_data_lj_type*)pair_data).sigma[center_index]+
    (*(pair_data_lj_type*)pair_data).sigma[other_index]
  );
  epsilon = sqrt(
    (*(pair_data_lj_type*)pair_data).epsilon[center_index]*
    (*(pair_data_lj_type*)pair_data).epsilon[other_index]
  );
  double t1 = pow(rcut, 0.2e1);
  double t2 = t1 * rcut;
  double t3 = t1 * t1;
  double t4 = t3 * t2;
  double t5 = rcut - width;
  double t6 = t5 * t5;
  double t8 = t6 * t6;
  double t9 = t8 * t6 * t5;
  double t10 = t4 * t9;
  double t11 = log(t5);
  double t13 = log(rcut);
  double t15 = t3 * t3;
  double t20 = pow(width, 0.2e1);
  double t24 = t20 * width;
  double t28 = t20 * t20;
  double t31 = t28 * width;
  double t34 = t28 * t20;
  double t37 = pow(sigma, 0.2e1);
  double t38 = t37 * t37;
  double t39 = t38 * t37;
  double t54 = t15 * t3 - 0.6e1 * width * t15 * t2 + 0.15e2 * t20 * t15 * t1 - 0.20e2 * t24 * t15 * rcut + 0.15e2 * t28 * t15 - 0.6e1 * t4 * t31 + t34 * t3 * t1 - t39 * t20 * t3 / 0.18e2 + t39 * t24 * t2 / 0.9e1 - t39 * t28 * t1 / 0.9e1 + t39 * t31 * rcut / 0.18e2 - t39 * t34 / 0.84e2;
  double t68 = 0.8e1 * (-t10 * t11 + t10 * t13 - width * t54 * (-width / 0.2e1 + rcut)) * t39 * epsilon / t4 / t24 / t9;
  return t68;
}

double pair_tailcorr_cut_mm3(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := epsilon*(1.84e5*exp(-12*r/sigma)-r6scale*2.25*(sigma/r)**6);
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
  double sigma, epsilon, r6scale;
  int onlypauli;
  sigma = (
    (*(pair_data_mm3_type*)pair_data).sigma[center_index]+
    (*(pair_data_mm3_type*)pair_data).sigma[other_index]
  );
  epsilon = sqrt(
    (*(pair_data_mm3_type*)pair_data).epsilon[center_index]*
    (*(pair_data_mm3_type*)pair_data).epsilon[other_index]
  );
  onlypauli = (
    (*(pair_data_mm3_type*)pair_data).onlypauli[center_index]+
    (*(pair_data_mm3_type*)pair_data).onlypauli[other_index]
  );
  if (onlypauli==0) r6scale = 1.0;
  else r6scale = 0.0;
  double t2 = pow(sigma, 0.2e1);
  double t3 = t2 * t2;
  double t8 = 0.12e2 * rcut / sigma;
  double t9 = exp(t8);
  double t12 = pow(rcut, 0.2e1);
  double t13 = t12 * t12;
  double t18 = t12 * rcut;
  double t22 = exp(-t8);
  double t28 = -0.9259259259e-2 * sigma * epsilon * (0.81e2 * r6scale * t3 * sigma * t9 - 0.1656000e7 * t13 * rcut - 0.276000e6 * sigma * t13 - 0.23000e5 * t2 * t18) * t22 / t18;
  return t28;
}

double pair_tailcorr_switch3_mm3(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := epsilon*(1.84e5*exp(-12*r/sigma)-r6scale*2.25*(sigma/r)**6);
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
  double sigma, epsilon, r6scale;
  int onlypauli;
  sigma = (
    (*(pair_data_mm3_type*)pair_data).sigma[center_index]+
    (*(pair_data_mm3_type*)pair_data).sigma[other_index]
  );
  epsilon = sqrt(
    (*(pair_data_mm3_type*)pair_data).epsilon[center_index]*
    (*(pair_data_mm3_type*)pair_data).epsilon[other_index]
  );
  onlypauli = (
    (*(pair_data_mm3_type*)pair_data).onlypauli[center_index]+
    (*(pair_data_mm3_type*)pair_data).onlypauli[other_index]
  );
  if (onlypauli==0) r6scale = 1.0;
  else r6scale = 0.0;
  double t1 = 0.1e1 / sigma;
  double t3 = 0.12e2 * rcut * t1;
  double t4 = exp(-t3);
  double t6 = pow(sigma, 0.2e1);
  double t7 = t6 * sigma;
  double t9 = 0.6000000003e1 * width;
  double t10 = 0.1000000000e1 * sigma;
  double t12 = pow(rcut, 0.2e1);
  double t13 = t12 * t12;
  double t14 = t13 * t12;
  double t16 = pow(width, 0.2e1);
  double t18 = 0.6666666670e0 * t6;
  double t19 = sigma * width;
  double t22 = t13 * rcut;
  double t24 = t16 * width;
  double t26 = 0.1388888889e0 * t7;
  double t27 = t6 * width;
  double t29 = sigma * t16;
  double t33 = t16 * t16;
  double t35 = t7 * width;
  double t36 = 0.1388888889e0 * t35;
  double t37 = t6 * t16;
  double t42 = t12 * rcut;
  double t47 = exp(0.12e2 * t1 * width);
  double t54 = 0.4226086958e-1 * r6scale * t42 * t35;
  double t55 = 0.4226086958e-1 * r6scale * t13 * t7 - t54;
  double t59 = log(0.1e1 * rcut - 0.1e1 * width);
  double t61 = log(rcut);
  double t75 = exp(t3);
  double t102 = -0.1064814814e3 * t4 * epsilon * t7 * (((-t9 + t10) * t14 + (0.1800000001e2 * t16 + t18 - 0.6000000003e1 * t19) * t22 + (-0.1800000001e2 * t24 + t26 - 0.1833333334e1 * t27 + 0.9000000004e1 * t29) * t13 + (0.6000000003e1 * t33 - t36 + 0.1166666667e1 * t37 - 0.4000000002e1 * sigma * t24) * t42) * t47 + (t55 * t59 - t55 * t61 - 0.2817391306e-11 * r6scale * t7 * t33 + t54 - 0.2113043479e-1 * r6scale * t12 * t7 * t16 + 0.2817391306e-11 * r6scale * rcut * t7 * t24) * t75 + (-t10 - t9) * t14 + (-0.2000000001e1 * t19 - t18 + 0.6000000003e1 * t16) * t22 + (0.1666666667e0 * t27 + 0.3000000001e1 * t29 - t26 - 0.9391304355e-9 * t24) * t13 + (t36 + 0.5000000002e0 * t37 + 0.9391304355e-9 * t33) * t42) / t42 / t24 / (rcut - width);
  return t102;
}

double pair_tailcorr_cut_grimme(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := -1.1*c6/r**6;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
// The damping functions is ignored: it is difficult to integrate and should
// not play a role for the large values of r considered here
  double c6;
  c6 = sqrt(
    (*(pair_data_grimme_type*)pair_data).c6[center_index]*
    (*(pair_data_grimme_type*)pair_data).c6[other_index]
  );
  double t1 = pow(rcut, 0.2e1);
  double t6 = -0.3666666667e0 * c6 / t1 / rcut;
  return t6;
}

double pair_tailcorr_switch3_grimme(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := -1.1*c6/r**6;
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
// The damping functions is ignored: it is difficult to integrate and should
// not play a role for the large values of r considered here
  double c6;
  c6 = sqrt(
    (*(pair_data_grimme_type*)pair_data).c6[center_index]*
    (*(pair_data_grimme_type*)pair_data).c6[other_index]
  );
  double t1 = log(rcut);
  double t2 = pow(rcut, 0.2e1);
  double t9 = log(0.1e1 * rcut - 0.1e1 * width);
  double t14 = pow(width, 0.2e1);
  double t26 = 0.22e1 * c6 * (t1 * t2 - t1 * rcut * width - t9 * t2 + t9 * rcut * width - rcut * width + 0.5e0 * t14) / rcut / (rcut - width) / t14 / width;
  return t26;
}

double pair_tailcorr_cut_exprep(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := amp*exp(-b*r);
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
  long i;
  double amp, b;
  pair_data_exprep_type *pd;
  pd = (pair_data_exprep_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  amp = (*pd).amp_cross[i];
  b = (*pd).b_cross[i];
  if (b==0.0) amp = 0.0;
  double t1 = pow(b, 0.2e1);
  double t2 = pow(rcut, 0.2e1);
  double t4 = b * rcut;
  double t8 = exp(-t4);
  double t12 = 0.1e1 / t1 / b * t8 * (t2 * t1 + 0.2e1 * t4 + 0.2e1) * amp;
  return t12;
}

double pair_tailcorr_switch3_exprep(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := amp*exp(-b*r);
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
  long i;
  double amp, b;
  pair_data_exprep_type *pd;
  pd = (pair_data_exprep_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  amp = (*pd).amp_cross[i];
  b = (*pd).b_cross[i];
  if (b==0.0) amp = 0.0;
  double t1 = (double) rcut - width;
  double t2 = t1 * t1;
  double t4 = pow(b, 0.2e1);
  double t5 = t4 * b;
  double t12 = 16 * rcut;
  double t18 = exp(-t1 * b);
  double t20 = (int) pow((double) rcut, (double) 2);
  double t33 = exp(-b * (double) rcut);
  double t37 = pow(width, 0.2e1);
  double t40 = t4 * t4;
  double t45 = 0.6e1 / t40 / t4 / t37 / width * amp * (t18 * (-0.40e2 + t5 * t2 * width - 0.2e1 * t4 * ((double) rcut - 0.4e1 * width) * t1 + b * (-(double) t12 + 0.28e2 * width)) + t33 * (0.40e2 + width * (double) t20 * t5 + 0.2e1 * t4 * ((double) rcut + 0.3e1 * width) * (double) rcut + b * ((double) t12 + 0.12e2 * width)));
  return t45;
}

double pair_tailcorr_cut_qmdffrep(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := amp/r*exp(-b*r);
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
  long i;
  double amp, b;
  pair_data_qmdffrep_type *pd;
  pd = (pair_data_qmdffrep_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  amp = (*pd).amp_cross[i];
  b = (*pd).b_cross[i];
  if (b==0.0) amp = 0.0;
  double t1 = b * rcut;
  double t2 = exp(-t1);
  double t5 = pow(b, 0.2e1);
  double t8 = 0.1e1 / t5 * (t1 + 0.1e1) * amp * t2;
  return t8;
}

double pair_tailcorr_switch3_qmdffrep(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := amp/r*exp(-b*r);
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
  long i;
  double amp, b;
  pair_data_qmdffrep_type *pd;
  pd = (pair_data_qmdffrep_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  amp = (*pd).amp_cross[i];
  b = (*pd).b_cross[i];
  if (b==0.0) amp = 0.0;
  double t1 = (double) rcut - width;
  double t3 = pow(b, 0.2e1);
  double t5 = 2 * rcut;
  double t11 = exp(-t1 * b);
  double t14 = exp(-b * (double) rcut);
  double t24 = pow(width, 0.2e1);
  double t27 = t3 * t3;
  double t32 = 0.6e1 / t27 / b / t24 / width * (t11 * (-0.8e1 + t3 * t1 * width + b * (-(double) t5 + 0.5e1 * width)) + (0.8e1 + width * (double) rcut * t3 + b * ((double) t5 + 0.3e1 * width)) * t14) * amp;
  return t32;
}

double pair_tailcorr_cut_ljcross(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 4*epsilon*( (sigma/r)**12 - (sigma/r)**6 );
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
  long i;
  double sigma, epsilon;
  // Load parameters from data structure and mix
  pair_data_ljcross_type *pd;
  pd = (pair_data_ljcross_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  epsilon = (*pd).eps_cross[i];
  sigma = (*pd).sig_cross[i];
  double t1 = pow(sigma, 0.2e1);
  double t2 = t1 * t1;
  double t3 = t2 * t1;
  double t5 = pow(rcut, 0.2e1);
  double t6 = t5 * t5;
  double t10 = t6 * t6;
  double t16 = -0.4e1 / 0.9e1 * epsilon * t3 * (0.3e1 * t6 * t5 - t3) / t10 / rcut;
  return t16;
}

double pair_tailcorr_switch3_ljcross(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 4*epsilon*( (sigma/r)**12 - (sigma/r)**6 );
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
  long i;
  double sigma, epsilon;
  // Load parameters from data structure and mix
  pair_data_ljcross_type *pd;
  pd = (pair_data_ljcross_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  epsilon = (*pd).eps_cross[i];
  sigma = (*pd).sig_cross[i];
  double t1 = pow(sigma, 0.2e1);
  double t2 = t1 * t1;
  double t3 = t2 * t1;
  double t4 = pow(rcut, 0.2e1);
  double t5 = t4 * rcut;
  double t6 = t4 * t4;
  double t7 = t6 * t5;
  double t8 = rcut - width;
  double t9 = t8 * t8;
  double t11 = t9 * t9;
  double t12 = t11 * t9 * t8;
  double t13 = t7 * t12;
  double t14 = log(t8);
  double t16 = log(rcut);
  double t18 = t6 * t6;
  double t23 = pow(width, 0.2e1);
  double t27 = t23 * width;
  double t31 = t23 * t23;
  double t34 = t31 * width;
  double t37 = t31 * t23;
  double t54 = t18 * t6 - 0.6e1 * width * t18 * t5 + 0.15e2 * t23 * t18 * t4 - 0.20e2 * t27 * t18 * rcut + 0.15e2 * t31 * t18 - 0.6e1 * t7 * t34 + t37 * t6 * t4 - t3 * t23 * t6 / 0.18e2 + t3 * t27 * t5 / 0.9e1 - t3 * t31 * t4 / 0.9e1 + t3 * t34 * rcut / 0.18e2 - t3 * t37 / 0.84e2;
  double t68 = 0.8e1 * t3 * (-t13 * t14 + t13 * t16 - t54 * (-width / 0.2e1 + rcut) * width) * epsilon / t7 / t27 / t12;
  return t68;
}

double pair_tailcorr_cut_dampdisp(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := -cn/r**power;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
  // Neglect the damping for the tailcorrections
  long i,power;
  double cn;
  // Load parameters from data structure and mix
  pair_data_dampdisp_type *pd;
  pd = (pair_data_dampdisp_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  power = (*pd).power;
  cn = (*pd).cn_cross[i];
  double t1 = 3 - power;
  double t2 = pow(rcut, (double) t1);
  double t6 = cn / (double) t1 * t2;
  return t6;
}

double pair_tailcorr_switch3_dampdisp(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := -cn/r**power;
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
  // Neglect the damping for the tailcorrections
  long i,power;
  double cn;
  // Load parameters from data structure and mix
  pair_data_dampdisp_type *pd;
  pd = (pair_data_dampdisp_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  power = (*pd).power;
  cn = (*pd).cn_cross[i];
  double t5 = rcut - width;
  double t6 = t5 * t5;
  double t7 = t6 * t6;
  double t10 = pow(t5, -power);
  double t12 = power - 0.6e1;
  double t14 = -power + 0.5e1;
  double t15 = pow(rcut, t14);
  double t18 = pow(rcut, -t12);
  double t21 = pow(width, 0.2e1);
  double t35 = -0.12e2 / (power - 0.3e1) / (power - 0.4e1) / t12 / t14 / t21 / width * (t10 * t7 * t5 * ((-power / 0.2e1 + 0.2e1) * width + rcut) - t15 * t12 * width / 0.2e1 - t18) * cn;
  return t35;
}

double pair_tailcorr_cut_disp68bjdamp(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := -c6/r**6-c8/r**8;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
  long i;
  double c6, c8;
  // Load parameters from data structure
  pair_data_disp68bjdamp_type *pd;
  pd = (pair_data_disp68bjdamp_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  c6 = (*pd).c6_cross[i]*(*pd).c6_scale;
  c8 = (*pd).c8_cross[i]*(*pd).c8_scale;
  double t1 = pow(rcut, 0.2e1);
  double t6 = t1 * t1;
  double t10 = (-0.5e1 * c6 * t1 - (double) (3 * c8)) / t6 / rcut / 0.15e2;
  return t10;
}

double pair_tailcorr_switch3_disp68bjdamp(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := -c6/r**6-c8/r**8;
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
  long i;
  double c6, c8;
  // Load parameters from data structure
  pair_data_disp68bjdamp_type *pd;
  pd = (pair_data_disp68bjdamp_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  c6 = (*pd).c6_cross[i]*(*pd).c6_scale;
  c8 = (*pd).c8_cross[i]*(*pd).c8_scale;
  double t1 = pow(rcut, 0.2e1);
  double t2 = t1 * rcut;
  double t3 = c6 * t2;
  double t4 = rcut - width;
  double t5 = t4 * t4;
  double t6 = t5 * t4;
  double t7 = log(t4);
  double t11 = log(rcut);
  double t18 = t1 * t1;
  double t24 = pow(width, 0.2e1);
  double t39 = (-0.20e2 * t3 * t6 * t7 + 0.20e2 * t3 * t6 * t11 - 0.2e1 * width * (rcut - width / 0.2e1) * (0.10e2 * c6 * t1 * t24 + 0.10e2 * c6 * t18 + c8 * t24 - 0.20e2 * t3 * width)) / t2 / t24 / width / t6 / 0.10e2;
  return t39;
}

double pair_tailcorr_cut_ei(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 1/r;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
//Never use tailcorrections for this potential, a trick like the Ewald summation is necessary in this case.
  double t1 = 0.0;
  return t1;
}

double pair_tailcorr_switch3_ei(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 1/r;
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
//Never use tailcorrections for this potential, a trick like the Ewald summation is necessary in this case.
  double t1 = 0.0;
  return t1;
}

double pair_tailcorr_cut_eidip(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 1/r;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
//Never use tailcorrections for this potential, a trick like the Ewald summation is necessary in this case.
  double t1 = 0.0;
  return t1;
}

double pair_tailcorr_switch3_eidip(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 1/r;
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
//Never use tailcorrections for this potential, a trick like the Ewald summation is necessary in this case.
  double t1 = 0.0;
  return t1;
}

double pair_tailcorr_cut_eislater1s1scorr(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 0;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
//Contribution to tailcorrections assumed to be zero
  double t1 = 0;
  return t1;
}

double pair_tailcorr_switch3_eislater1s1scorr(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 0;
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
//Contribution to tailcorrections assumed to be zero
  double t1 = 0;
  return t1;
}

double pair_tailcorr_cut_eislater1sp1spcorr(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 0;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
//Contribution to tailcorrections assumed to be zero
  double t1 = 0;
  return t1;
}

double pair_tailcorr_switch3_eislater1sp1spcorr(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 0;
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
//Contribution to tailcorrections assumed to be zero
  double t1 = 0;
  return t1;
}

double pair_tailcorr_cut_olpslater1s1s(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 0;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
//Contribution to tailcorrections assumed to be zero
  double t1 = 0;
  return t1;
}

double pair_tailcorr_switch3_olpslater1s1s(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 0;
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
//Contribution to tailcorrections assumed to be zero
  double t1 = 0;
  return t1;
}

double pair_tailcorr_cut_chargetransferslater1s1s(void *pair_data, long center_index, long other_index, double rcut) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 0;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity));
MyC(ecorr,optimize);

  */
//Contribution to tailcorrections assumed to be zero
  double t1 = 0;
  return t1;
}

double pair_tailcorr_switch3_chargetransferslater1s1s(void *pair_data, long center_index, long other_index, double rcut, double width) {
  /*
  This C code is generated by Maple using the following commands:
interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

V := 0;
x := (rcut-r)/width;
switch := 3*x**2-2*x**3;
ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));
MyC(ecorr,optimize);

  */
//Contribution to tailcorrections assumed to be zero
  double t1 = 0;
  return t1;
}
