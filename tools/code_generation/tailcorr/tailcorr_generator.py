#!/usr/bin/env python
# -*- coding: utf-8 -*-
# YAFF is yet another force-field code.
# Copyright (C) 2011 Toon Verstraelen <Toon.Verstraelen@UGent.be>,
# Louis Vanduyfhuys <Louis.Vanduyfhuys@UGent.be>, Center for Molecular Modeling
# (CMM), Ghent University, Ghent, Belgium; all rights reserved unless otherwise
# stated.
#
# This file is part of YAFF.
#
# YAFF is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# YAFF is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --

import subprocess

# Location of the maple executable
maple = "/home/steven/bin/maple2017/bin/maple"

def generate_function(name, prep, expr, tr="cut"):
    '''
    Generate C code that computes tail corrections for a pair of atoms
    '''
    if tr=='cut':
        ecorr_code = "\necorr := simplify(integrate(r**2*V,r=rcut..infinity));"
        extra_args = ""
    elif tr=='switch3':
        ecorr_code = "\nx := (rcut-r)/width;\nswitch := 3*x**2-2*x**3;\n"
        ecorr_code += "ecorr := simplify(integrate(r**2*V,r=rcut..infinity) + integrate(r**2*V*(1-switch),r=rcut-width..rcut));"
        extra_args = ", double width"
    else: raise NotImplementedError

    # Write Maple input file
    maple_code = """interface(echo=0):
assume(width > 0, rcut > width, r > 0, sigma>0, epsilon>0, r0>0, c6>0, amp>0, b>0, cn>0, power::integer, power>3, R0>0);
with(StringTools):
with(CodeGeneration):
with(LinearAlgebra):

CodeGeneration:-LanguageDefinition:-Define( "MyC", extend="C", SetLanguageAttribute("Name_IsValid"=true) );
MyC := () -> CodeGeneration:-Translate(args, language="MyC" );

"""
    maple_code += expr
    maple_code += "%s\nMyC(ecorr,optimize);\n"%(ecorr_code)
    fn_mpl = 'expr_tmp.mpl'
    with open(fn_mpl,'w') as f:
        f.write(maple_code)
    # Execute Maple
    (out,err) = subprocess.Popen(['''%s %s'''%(maple,fn_mpl)], stdout=subprocess.PIPE, shell=True).communicate()
    # Function definition
    header_code = """double pair_tailcorr_%s_%s(void *pair_data, long center_index, long other_index, double rcut%s);\n""" %(tr,name,extra_args)
    code = """
double pair_tailcorr_%s_%s(void *pair_data, long center_index, long other_index, double rcut%s) {
  /*
  This C code is generated by Maple using the following commands:
%s
  */""" % (tr,name,extra_args,maple_code)
    code += prep
    # Read the Maple output
    return_var = "",""
    for line in out.split('\n'):
        if line.startswith('t'):
            code += '  double %s\n'%(line.replace('~',''))
            return_var = line.split()[0]
    code += "  return %s;\n}\n" % (return_var)
    return code, header_code

pair_potentials = [
    # Lennard-Jones
    ('lj',"""
  double sigma, epsilon;
  sigma = 0.5*(
    (*(pair_data_lj_type*)pair_data).sigma[center_index]+
    (*(pair_data_lj_type*)pair_data).sigma[other_index]
  );
  epsilon = sqrt(
    (*(pair_data_lj_type*)pair_data).epsilon[center_index]*
    (*(pair_data_lj_type*)pair_data).epsilon[other_index]
  );
""",
    "V:=4*epsilon*((sigma/r)**12-(sigma/r)**6);"),
    # MM3
    ('mm3',"""
  double sigma, epsilon, r6scale;
  int onlypauli;
  sigma = (
    (*(pair_data_mm3_type*)pair_data).sigma[center_index]+
    (*(pair_data_mm3_type*)pair_data).sigma[other_index]
  );
  epsilon = sqrt(
    (*(pair_data_mm3_type*)pair_data).epsilon[center_index]*
    (*(pair_data_mm3_type*)pair_data).epsilon[other_index]
  );
  onlypauli = (
    (*(pair_data_mm3_type*)pair_data).onlypauli[center_index]+
    (*(pair_data_mm3_type*)pair_data).onlypauli[other_index]
  );
  if (onlypauli==0) r6scale = 1.0;
  else r6scale = 0.0;
""",
    "V := epsilon*(1.84e5*exp(-12*r/sigma)-r6scale*2.25*(sigma/r)**6);"),
    # Grimme
    ('grimme',"""
// The damping functions is ignored: it is difficult to integrate and should
// not play a role for the large values of r considered here
  double c6;
  c6 = sqrt(
    (*(pair_data_grimme_type*)pair_data).c6[center_index]*
    (*(pair_data_grimme_type*)pair_data).c6[other_index]
  );
""",
    "V := -1.1*c6/r**6;"),
    # ExpRep
    ('exprep',"""
  long i;
  double amp, b;
  pair_data_exprep_type *pd;
  pd = (pair_data_exprep_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  amp = (*pd).amp_cross[i];
  b = (*pd).b_cross[i];
  if (b==0.0) amp = 0.0;
""",
    "V := amp*exp(-b*r);"),
    # QMDFFRep
    ('qmdffrep',"""
  long i;
  double amp, b;
  pair_data_qmdffrep_type *pd;
  pd = (pair_data_qmdffrep_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  amp = (*pd).amp_cross[i];
  b = (*pd).b_cross[i];
  if (b==0.0) amp = 0.0;
""",
    "V := amp/r*exp(-b*r);"),
    # LJCross
    ('ljcross',"""
  long i;
  double sigma, epsilon;
  // Load parameters from data structure and mix
  pair_data_ljcross_type *pd;
  pd = (pair_data_ljcross_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  epsilon = (*pd).eps_cross[i];
  sigma = (*pd).sig_cross[i];
""",
    "V := 4*epsilon*( (sigma/r)**12 - (sigma/r)**6 );"),
    # DampDisp
    ('dampdisp', """
  // Neglect the damping for the tailcorrections
  long i,power;
  double cn;
  // Load parameters from data structure and mix
  pair_data_dampdisp_type *pd;
  pd = (pair_data_dampdisp_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  power = (*pd).power;
  cn = (*pd).cn_cross[i];
""",
    "V := -cn/r**power;"),
    #Disp68BJDamp
    ('disp68bjdamp',"""
  long i;
  double c6, c8;
  // Load parameters from data structure
  pair_data_disp68bjdamp_type *pd;
  pd = (pair_data_disp68bjdamp_type*)pair_data;
  i = (*pd).ffatype_ids[center_index]*(*pd).nffatype + (*pd).ffatype_ids[other_index];
  c6 = (*pd).c6_cross[i]*(*pd).c6_scale;
  c8 = (*pd).c8_cross[i]*(*pd).c8_scale;
""",
    "V := -c6/r**6-c8/r**8;"),
    # EI
    ('ei',"\n//Never use tailcorrections for this potential, a trick like the Ewald summation is necessary in this case.\n",
    'V := 1/r;'),
    # EIDip
    ('eidip',"\n//Never use tailcorrections for this potential, a trick like the Ewald summation is necessary in this case.\n",
    'V := 1/r;'),
    # eislater1s1scorr
    ('eislater1s1scorr','\n//Contribution to tailcorrections assumed to be zero\n','V := 0;'),
    # eislater1sp1spcorr
    ('eislater1sp1spcorr','\n//Contribution to tailcorrections assumed to be zero\n','V := 0;'),
    # olpslater1s1s
    ('olpslater1s1s','\n//Contribution to tailcorrections assumed to be zero\n','V := 0;'),
    # chargetransferslater1s1s
    ('chargetransferslater1s1s','\n//Contribution to tailcorrections assumed to be zero\n','V := 0;'),
]


def main():
    code_main = """#include <math.h>\n#include <stdlib.h>\n#include "pair_pot.h"\n"""
#    code_main
    code_header = ""
    for name, prep, expr in pair_potentials:
#    if not name in ['grimme']: continue
        for tr in ['cut','switch3']:
            ccode, hcode = generate_function(name, prep, expr, tr=tr)
            code_main += ccode.replace('= infinity','= 0.0')
            code_header += hcode
    with open('tailcorr.c','w') as f:
        f.write(code_main)
    with open('tailcorr.h','w') as f:
        f.write(code_header)


if __name__=='__main__':
    main()
